# goit-algo-hw-05
# Домашнє завдання №5 - Алгоритми пошуку

Цей проект реалізує та порівнює різні алгоритми пошуку: хеш-таблиці, двійковий пошук та алгоритми пошуку підрядків.

## Структура проекту

```
goit-algo-hw-05/
├── task1.py                    # HashTable з методом delete
├── task2.py                    # Двійковий пошук з верхньою межею
├── task3.py                    # Порівняння алгоритмів пошуку підрядків
├── стаття1.txt                 # Текстовий файл для тестування (опціонально)
├── стаття2.txt                 # Текстовий файл для тестування (опціонально)
└── README.md                   # Цей файл
```

## Завдання 1: HashTable з методом delete

### Опис
Розширення класу `HashTable` додаванням методу `delete` для видалення пар ключ-значення.

### Особливості реалізації
- Використовує метод ланцюжків для розв'язання колізій
- Правильно обробляє випадки відсутності ключа
- Підтримує додаткові методи: `keys()`, `values()`, `items()`, `__len__()`, `__contains__()`

### Використання
```bash
python3 task1.py
```

### Основні методи
- `insert(key, value)` - вставка або оновлення
- `get(key)` - отримання значення за ключем
- `delete(key)` - видалення пари ключ-значення
- `display()` - відображення структури таблиці

## Завдання 2: Двійковий пошук з верхньою межею

### Опис
Реалізація двійкового пошуку для відсортованого масиву дробових чисел з поверненням кількості ітерацій та "верхньої межі".

### Особливості
- Повертає кортеж `(кількість_ітерацій, верхня_межа)`
- Верхня межа - найменший елемент ≥ заданому значенню
- Обробляє випадки відсутності верхньої межі

### Використання
```bash
python3 task2.py
```

### Приклад роботи
```python
arr = [1.1, 2.3, 3.5, 4.7, 5.9]
iterations, upper_bound = binary_search_with_upper_bound(arr, 3.6)
# Результат: (3, 4.7) - 3 ітерації, верхня межа 4.7
```

## Завдання 3: Порівняння алгоритмів пошуку підрядків

### Опис
Порівняння ефективності трьох алгоритмів пошуку підрядків:
- **Boyer-Moore** - ефективний для довгих підрядків
- **Knuth-Morris-Pratt (KMP)** - стабільний для всіх випадків
- **Rabin-Karp** - добрий для коротких підрядків

### Тестові дані
Програма тестує алгоритми на двох типах підрядків:
1. **Існуючі** - підрядки, що дійсно присутні в тексті
2. **Вигадані** - підрядки, які ймовірно відсутні

### Використання
```bash
python3 task3.py
```

**Примітка**: Програма автоматично визначає кодування файлів (UTF-8, CP1251, Latin-1, CP866, UTF-16) та може працювати без текстових файлів, використовуючи вбудовані зразки тексту.

### Файли даних (опціонально)
- `стаття1.txt` - текст про алгоритми в бібліотеках
- `стаття2.txt` - текст про структури даних для БД

**Примітка про кодування файлів**: Програма автоматично визначає кодування текстових файлів, підтримуючи UTF-8, CP1251, Latin-1, CP866 та UTF-16. Якщо файли не знайдено або не вдається їх прочитати, використовуються вбудовані зразки тексту.

## Результати та висновки

### Завдання 1
- ✅ Метод `delete` успішно видаляє пари ключ-значення
- ✅ Правильно обробляє колізії та відсутні ключі
- ✅ Підтримує всі основні операції хеш-таблиці

### Завдання 2
- ✅ Двійковий пошук працює з O(log n) складністю
- ✅ Правильно знаходить верхню межу в усіх випадках
- ✅ Значно швидший за лінійний пошук (до 100x прискорення)

### Завдання 3
**Загальні висновки з порівняння алгоритмів:**

1. **Boyer-Moore**: Найкращий для довгих підрядків та великих алфавітів
2. **KMP**: Стабільна продуктивність, добре підходить для загального використання
3. **Rabin-Karp**: Ефективний для коротких підрядків та множинного пошуку

**Практичні рекомендації:**
- Для загального використання: **KMP**
- Для довгих підрядків: **Boyer-Moore**
- Для багатьох коротких підрядків: **Rabin-Karp**

## Технічні вимоги

- Python 3.6+
- Стандартні бібліотеки: `timeit`, `hashlib`
- Опціонально: текстові файли для тестування (підтримуються різні кодування: UTF-8, CP1251, Latin-1, CP866, UTF-16)

## Запуск тестів

```bash
# Тестування всіх завдань
python3 task1.py
python3 task2.py
python3 task3.py
```

**Примітка для task3.py**: Якщо виникає помилка кодування при читанні файлів, програма автоматично спробує різні кодування (UTF-8, CP1251, Latin-1, CP866, UTF-16) та у випадку невдачі використає вбудовані зразки тексту.


